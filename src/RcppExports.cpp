// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/LambertW.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// kurtosis
double kurtosis(const NumericVector& x);
RcppExport SEXP LambertW_kurtosis(SEXP xSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::RNGScope __rngScope;
    Rcpp::traits::input_parameter< const NumericVector& >::type x(xSEXP);
    __result = Rcpp::wrap(kurtosis(x));
    return __result;
END_RCPP
}
// lp_norm_Cpp
double lp_norm_Cpp(const NumericVector& x, double p);
RcppExport SEXP LambertW_lp_norm_Cpp(SEXP xSEXP, SEXP pSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::RNGScope __rngScope;
    Rcpp::traits::input_parameter< const NumericVector& >::type x(xSEXP);
    Rcpp::traits::input_parameter< double >::type p(pSEXP);
    __result = Rcpp::wrap(lp_norm_Cpp(x, p));
    return __result;
END_RCPP
}
// lp_norm_complex_Cpp
double lp_norm_complex_Cpp(const ComplexVector& x, double p);
RcppExport SEXP LambertW_lp_norm_complex_Cpp(SEXP xSEXP, SEXP pSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::RNGScope __rngScope;
    Rcpp::traits::input_parameter< const ComplexVector& >::type x(xSEXP);
    Rcpp::traits::input_parameter< double >::type p(pSEXP);
    __result = Rcpp::wrap(lp_norm_complex_Cpp(x, p));
    return __result;
END_RCPP
}
// normalize_by_tau_Cpp
NumericVector normalize_by_tau_Cpp(const NumericVector& x, double mu_x, double sigma_x, bool inverse);
RcppExport SEXP LambertW_normalize_by_tau_Cpp(SEXP xSEXP, SEXP mu_xSEXP, SEXP sigma_xSEXP, SEXP inverseSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::RNGScope __rngScope;
    Rcpp::traits::input_parameter< const NumericVector& >::type x(xSEXP);
    Rcpp::traits::input_parameter< double >::type mu_x(mu_xSEXP);
    Rcpp::traits::input_parameter< double >::type sigma_x(sigma_xSEXP);
    Rcpp::traits::input_parameter< bool >::type inverse(inverseSEXP);
    __result = Rcpp::wrap(normalize_by_tau_Cpp(x, mu_x, sigma_x, inverse));
    return __result;
END_RCPP
}
// skewness
double skewness(const NumericVector& x);
RcppExport SEXP LambertW_skewness(SEXP xSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::RNGScope __rngScope;
    Rcpp::traits::input_parameter< const NumericVector& >::type x(xSEXP);
    __result = Rcpp::wrap(skewness(x));
    return __result;
END_RCPP
}
// W_Cpp
NumericVector W_Cpp(const NumericVector& z, int branch);
static SEXP LambertW_W_Cpp_try(SEXP zSEXP, SEXP branchSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::traits::input_parameter< const NumericVector& >::type z(zSEXP);
    Rcpp::traits::input_parameter< int >::type branch(branchSEXP);
    __result = Rcpp::wrap(W_Cpp(z, branch));
    return __result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP LambertW_W_Cpp(SEXP zSEXP, SEXP branchSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(LambertW_W_Cpp_try(zSEXP, branchSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// W_delta_Cpp
NumericVector W_delta_Cpp(const NumericVector& z, double delta);
static SEXP LambertW_W_delta_Cpp_try(SEXP zSEXP, SEXP deltaSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::traits::input_parameter< const NumericVector& >::type z(zSEXP);
    Rcpp::traits::input_parameter< double >::type delta(deltaSEXP);
    __result = Rcpp::wrap(W_delta_Cpp(z, delta));
    return __result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP LambertW_W_delta_Cpp(SEXP zSEXP, SEXP deltaSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(LambertW_W_delta_Cpp_try(zSEXP, deltaSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// W_delta_alpha_Cpp
NumericVector W_delta_alpha_Cpp(const NumericVector& z, double delta, double alpha);
static SEXP LambertW_W_delta_alpha_Cpp_try(SEXP zSEXP, SEXP deltaSEXP, SEXP alphaSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::traits::input_parameter< const NumericVector& >::type z(zSEXP);
    Rcpp::traits::input_parameter< double >::type delta(deltaSEXP);
    Rcpp::traits::input_parameter< double >::type alpha(alphaSEXP);
    __result = Rcpp::wrap(W_delta_alpha_Cpp(z, delta, alpha));
    return __result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP LambertW_W_delta_alpha_Cpp(SEXP zSEXP, SEXP deltaSEXP, SEXP alphaSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(LambertW_W_delta_alpha_Cpp_try(zSEXP, deltaSEXP, alphaSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// W_gamma_Cpp
NumericVector W_gamma_Cpp(const NumericVector& z, double gamma, int branch);
static SEXP LambertW_W_gamma_Cpp_try(SEXP zSEXP, SEXP gammaSEXP, SEXP branchSEXP) {
BEGIN_RCPP
    Rcpp::RObject __result;
    Rcpp::traits::input_parameter< const NumericVector& >::type z(zSEXP);
    Rcpp::traits::input_parameter< double >::type gamma(gammaSEXP);
    Rcpp::traits::input_parameter< int >::type branch(branchSEXP);
    __result = Rcpp::wrap(W_gamma_Cpp(z, gamma, branch));
    return __result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP LambertW_W_gamma_Cpp(SEXP zSEXP, SEXP gammaSEXP, SEXP branchSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(LambertW_W_gamma_Cpp_try(zSEXP, gammaSEXP, branchSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}

// validate (ensure exported C++ functions exist before calling them)
static int LambertW_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("NumericVector(*W_Cpp)(const NumericVector&,int)");
        signatures.insert("NumericVector(*W_delta_Cpp)(const NumericVector&,double)");
        signatures.insert("NumericVector(*W_delta_alpha_Cpp)(const NumericVector&,double,double)");
        signatures.insert("NumericVector(*W_gamma_Cpp)(const NumericVector&,double,int)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP LambertW_RcppExport_registerCCallable() { 
    R_RegisterCCallable("LambertW", "LambertW_W_Cpp", (DL_FUNC)LambertW_W_Cpp_try);
    R_RegisterCCallable("LambertW", "LambertW_W_delta_Cpp", (DL_FUNC)LambertW_W_delta_Cpp_try);
    R_RegisterCCallable("LambertW", "LambertW_W_delta_alpha_Cpp", (DL_FUNC)LambertW_W_delta_alpha_Cpp_try);
    R_RegisterCCallable("LambertW", "LambertW_W_gamma_Cpp", (DL_FUNC)LambertW_W_gamma_Cpp_try);
    R_RegisterCCallable("LambertW", "LambertW_RcppExport_validate", (DL_FUNC)LambertW_RcppExport_validate);
    return R_NilValue;
}
